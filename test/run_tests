#!/usr/bin/perl
use warnings;
use strict;

sub interrupt
{
	exit 25
}
$SIG{INT} = \&interrupt;

sub basename
{
	my $f = shift;
	return $1 if $f =~ m;/([^/]+)$;;
	return $f;
}

sub usage
{
	die <<"!"
Usage: $0 [-k] [-s] [-v] [-j jobcount] [tests...]

-k: Keep going
-s: Silent, don't output commands about to run
-v: Verbose, subcommands emit extra information
-j: Run with asynchronous jobs
!
}

my $verbose = 0;
my $quiet = 0;
my $jobs = 1;
my $keep_going = 0;
my $progress = 0;
my @tests;

for(my $i = 0; $i < @ARGV; $i++){
	if($ARGV[$i] eq '-v'){
		$verbose = 1;
	}elsif($ARGV[$i] eq '-s'){
		$quiet = 1;
	}elsif($ARGV[$i] eq '-k'){
		$keep_going = 1;
	}elsif($ARGV[$i] eq '-P'){
		$progress = 1;
	}elsif($ARGV[$i] =~ /^-j(.*)$/){
		my $n = $1;
		if($n eq ''){
			$i++;
			die "$0: need number for -j\n" if $i == @ARGV;
			$n = $ARGV[$i];
		}
		die "$0: '$n' not a number\n" if $n !~ /^[0-9]+$/;
		die "$0: '$n' less than 1\n" if $n < 1;

		$jobs = $n;

	}else{
		if($ARGV[$i] =~ /^-/){
			if($ARGV[$i] eq '--'){
				$i++;
				push @tests, @ARGV[$i ... $#ARGV];
				last;
			}else{
				usage();
			}
		}

		push @tests, $ARGV[$i];
	}
}

my $envtmp = $ENV{TMPDIR} || "/tmp/";
my $tdir = "$envtmp/ucc.test.$$/";
if(not -d $tdir and not mkdir($tdir)){
	die "$0: mkdir $tdir: $!\n";
}

$ENV{UCC} = '../ucc';
$ENV{UCC_TESTDIR} = $tdir;

if($verbose){
	$ENV{UCC_VERBOSE} = 1;
}else{
	delete $ENV{UCC_VERBOSE};
}

my $ec = 0;
my %tasks; # pid => { output, testfile }

sub cursor_clrtoeol
{
	print "\e[K";
}

sub find_tests
{
	# DFS
	my @found;
	for my $ent (@_){
		if(-d $ent){
			push @found, find_tests(glob "$ent/*");
		}elsif($ent =~ /\.c$/){
			push @found, $ent;
		}
	}
	return @found;
}

sub reap_all_tests
{
	reap_test() while keys %tasks;
}

sub reap_test
{
	my $pid = wait;
	my $rc = $?;

	if(!exists $tasks{$pid}){
		warn "$0: unknown child $pid\n";
		for(keys %tasks){
			warn "pid: $_, testfile: $tasks{$_}->{testfile}\n";
		}
		exit 1;
	}

	if($rc & 127){
		die "test $tasks{$pid}->{testfile} caught signal " . ($rc & 127) . "\n";
	}
	$rc >>= 8; # exit code

	my $desc = ($rc ? 'fail' : 'pass');

	if(not $quiet or $rc){
		print "$desc: $tasks{$pid}->{testfile}\n";
	}

	my $output = $tasks{$pid}->{output};
	delete $tasks{$pid};

	if($rc){
		$ec = 1;
		system('cat', $output);

		if(!$keep_going){
			# had failure - reap all tests and exit
			print STDERR "$0: waiting for remaining tasks...\n"
			if keys %tasks;

			reap_all_tests();
			exit(1);
		}
	}
}

sub launch_test
{
	print "$0: $_[1]\n" if $verbose;

	my $pid = fork();
	die "$0: fork: $!\n" if $pid < 0;

	if($pid == 0){
		my $f = "$tdir/$$.all";

		open STDIN, '</dev/null' or die;
		open STDOUT, '>', $f or die;
		open STDERR, '>&STDOUT' or die;

		exec @_;
		die "exec: $!";
	}

	my $f = "$tdir/$pid.all";
	$tasks{$pid} = { output => $f, testfile => $_[1] };
}

sub show_progress
{
	my($i, $n) = @_;

	printf "%d%% (%d/%d)\r", $i / $n * 100, $i, $n;
}

my @test_files = find_tests(@tests);
die "$0: no tests found\n" unless @test_files;

$| = 1 if $progress;

for(my $fi = 0; $fi < @test_files; $fi++){
	reap_test() while keys %tasks >= $jobs;

	show_progress($fi + 1, scalar @test_files) if $progress;

	my $f = $test_files[$fi];
	launch_test('./bin/test.pl', $f);

	show_progress($fi + 1, scalar @test_files) if $progress;
}

reap_all_tests();

system('rm', '-rf', $tdir) if defined $tdir;

exit $ec;
